package com.minewright.evaluation;

import com.minewright.llm.PromptMetrics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Comprehensive metrics collection for academic evaluation of Steve AI.
 *
 * <p>This class provides thread-safe tracking of all performance, cost, and quality metrics
 * required for rigorous evaluation of the dissertation claims. Metrics are automatically
 * collected during normal operation and can be exported to JSON for analysis.</p>
 *
 * <p><b>Thread Safety:</b> All methods are thread-safe and can be called from any thread.</p>
 *
 * <p><b>Usage:</b></p>
 * <pre>
 * // Start tracking a task
 * EvaluationMetrics.recordTaskStart("Steve-1", "Mine 10 stone");
 *
 * // Record planning completion
 * EvaluationMetrics.recordPlanningComplete("Steve-1", 2340, 5);
 *
 * // Record LLM call
 * EvaluationMetrics.recordLLMCall("openai", "gpt-4", 1250, 180, 0.045, 2300, false);
 *
 * // Mark task complete
 * EvaluationMetrics.recordTaskComplete("Steve-1", true, 1.0, Map.of("blocks_mined", 10));
 *
 * // Export results
 * EvaluationMetrics.exportToJson("/path/to/results.json");
 * </pre>
 *
 * @since 1.0.0
 */
public class EvaluationMetrics {
    private static final Logger LOGGER = LoggerFactory.getLogger(EvaluationMetrics.class);

    // Per-task tracking (thread-safe)
    private static final Map<String, TaskMetrics> activeTasks = new ConcurrentHashMap<>();
    private static final List<CompletedTaskMetrics> completedTasks = new ArrayList<>();
    private static final AtomicLong totalCostCents = new AtomicLong(0);

    // Benchmark metadata
    private static String benchmarkRunId = UUID.randomUUID().toString();
    private static String benchmarkVersion = "1.0";
    private static long benchmarkStartTime = System.currentTimeMillis();
    private static String systemInfo = getSystemInfo();

    /**
     * Enum representing execution phases.
     */
    public enum ExecutionPhase {
        PLANNING,
        EXECUTION,
        COMPLETE,
        FAILED
    }

    /**
     * Record the start of planning phase for a task.
     *
     * @param agentName Name of the agent performing the task
     * @param timestamp Start timestamp (milliseconds since epoch)
     */
    public static void recordPlanningStart(String agentName, long timestamp) {
        TaskMetrics metrics = getOrCreateTaskMetrics(agentName);
        metrics.planningStartTime = timestamp;
        metrics.phase = ExecutionPhase.PLANNING;

        LOGGER.debug("[{}] Planning phase started", agentName);
    }

    /**
     * Record the completion of planning phase.
     *
     * @param agentName Name of the agent
     * @param latencyMs Time taken for planning in milliseconds
     * @param taskCount Number of tasks generated by the LLM
     */
    public static void recordPlanningComplete(String agentName, long latencyMs, int taskCount) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            LOGGER.warn("[{}] No active task metrics found", agentName);
            return;
        }

        metrics.planningLatencyMs = latencyMs;
        metrics.tasksGenerated = taskCount;
        metrics.phase = ExecutionPhase.EXECUTION;

        LOGGER.info("[{}] Planning completed: {}ms, {} tasks generated",
            agentName, latencyMs, taskCount);
    }

    /**
     * Record the start of execution phase.
     *
     * @param agentName Name of the agent
     * @param timestamp Start timestamp
     */
    public static void recordExecutionStart(String agentName, long timestamp) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            LOGGER.warn("[{}] No active task metrics found", agentName);
            return;
        }

        metrics.executionStartTime = timestamp;

        LOGGER.debug("[{}] Execution phase started", agentName);
    }

    /**
     * Record the start of an action within execution phase.
     *
     * @param agentName Name of the agent
     * @param actionType Type of action being started
     * @param timestamp Start timestamp
     */
    public static void recordActionStart(String agentName, String actionType, long timestamp) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            return;
        }

        metrics.currentAction = actionType;
        metrics.actionsStarted++;

        LOGGER.trace("[{}] Action '{}' started", agentName, actionType);
    }

    /**
     * Record the completion of an action.
     *
     * @param agentName Name of the agent
     * @param actionType Type of action that completed
     * @param latencyMs Time taken for the action
     * @param success Whether the action succeeded
     */
    public static void recordActionComplete(String agentName, String actionType,
                                            long latencyMs, boolean success) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            return;
        }

        metrics.actionsCompleted++;
        if (success) {
            metrics.actionsSuccessful++;
        } else {
            metrics.actionsFailed++;
        }

        LOGGER.debug("[{}] Action '{}' completed: {}ms, success={}",
            agentName, actionType, latencyMs, success);
    }

    /**
     * Record an LLM API call with full details.
     *
     * @param providerId LLM provider identifier (e.g., "openai", "groq")
     * @param model Model name (e.g., "gpt-4", "llama-3.1-8b-instant")
     * @param inputTokens Number of input tokens sent
     * @param outputTokens Number of output tokens received
     * @param costUsd Cost in USD
     * @param latencyMs Request latency in milliseconds
     * @param fromCache Whether response was served from cache
     */
    public static void recordLLMCall(String providerId, String model,
                                     int inputTokens, int outputTokens,
                                     double costUsd, long latencyMs,
                                     boolean fromCache) {
        // Update PromptMetrics for global tracking
        PromptMetrics.recordRequest(inputTokens, outputTokens);
        totalCostCents.addAndGet((long) (costUsd * 100));

        // Update all active tasks (supports multi-agent scenarios)
        for (TaskMetrics metrics : activeTasks.values()) {
            metrics.llmCalls++;
            metrics.inputTokens += inputTokens;
            metrics.outputTokens += outputTokens;
            metrics.llmCostUsd += costUsd;

            if (fromCache) {
                metrics.cacheHits++;
            }

            // Track latency distribution
            if (latencyMs < 1000) {
                metrics.latencyBuckets[0]++;
            } else if (latencyMs < 3000) {
                metrics.latencyBuckets[1]++;
            } else if (latencyMs < 10000) {
                metrics.latencyBuckets[2]++;
            } else {
                metrics.latencyBuckets[3]++;
            }
        }

        LOGGER.debug("[LLM] {} ({}): {} in + {} out tokens, ${}, {}ms, cache={}",
            providerId, model, inputTokens, outputTokens,
            String.format("%.6f", costUsd), latencyMs, fromCache);
    }

    /**
     * Record a task completion with final results.
     *
     * @param agentName Name of the agent
     * @param success Whether the task completed successfully
     * @param correctnessScore Correctness score (0.0 to 1.0)
     * @param results Map of result metrics (e.g., block counts, items crafted)
     */
    public static void recordTaskComplete(String agentName, boolean success,
                                         double correctnessScore,
                                         Map<String, Object> results) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            LOGGER.warn("[{}] No active task metrics found", agentName);
            return;
        }

        long completionTime = System.currentTimeMillis();
        long totalLatency = completionTime - metrics.planningStartTime;
        long executionLatency = completionTime - metrics.executionStartTime;

        metrics.success = success;
        metrics.correctnessScore = correctnessScore;
        metrics.results = results;
        metrics.completionTime = completionTime;
        metrics.totalLatencyMs = totalLatency;
        metrics.executionLatencyMs = executionLatency;
        metrics.phase = success ? ExecutionPhase.COMPLETE : ExecutionPhase.FAILED;

        // Move to completed list
        CompletedTaskMetrics completed = new CompletedTaskMetrics(metrics);
        synchronized (completedTasks) {
            completedTasks.add(completed);
        }
        activeTasks.remove(agentName);

        LOGGER.info("[{}] Task {}: success={}, correctness={:.2f}, total={}ms, cost=${:.4f}",
            agentName,
            success ? "COMPLETE" : "FAILED",
            success,
            correctnessScore,
            totalLatency,
            metrics.llmCostUsd);
    }

    /**
     * Record a task failure with error details.
     *
     * @param agentName Name of the agent
     * @param errorType Type of error (e.g., "planning", "execution", "timeout")
     * @param errorMessage Error message
     */
    public static void recordTaskFailure(String agentName, String errorType, String errorMessage) {
        TaskMetrics metrics = getTaskMetrics(agentName);
        if (metrics == null) {
            return;
        }

        metrics.errors.add(errorType + ": " + errorMessage);
        metrics.phase = ExecutionPhase.FAILED;

        LOGGER.error("[{}] Task failed: {} - {}", agentName, errorType, errorMessage);
    }

    /**
     * Export all collected metrics to JSON file.
     *
     * @param filepath Path to output JSON file
     */
    public static void exportToJson(String filepath) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filepath))) {
            StringBuilder json = new StringBuilder();
            json.append("{\n");
            json.append("  \"benchmark_run\": {\n");
            json.append("    \"run_id\": \"").append(benchmarkRunId).append("\",\n");
            json.append("    \"timestamp\": \"").append(LocalDateTime.now().format(
                DateTimeFormatter.ISO_DATE_TIME)).append("\",\n");
            json.append("    \"benchmark_version\": \"").append(benchmarkVersion).append("\",\n");
            json.append("    \"system_info\": \"").append(escapeJson(systemInfo)).append("\",\n");
            json.append("    \"duration_ms\": ").append(System.currentTimeMillis() - benchmarkStartTime).append(",\n");

            // Summary statistics
            synchronized (completedTasks) {
                json.append("    \"summary\": {\n");
                json.append("      \"total_tasks\": ").append(completedTasks.size()).append(",\n");
                long successfulTasks = completedTasks.stream().filter(t -> t.success).count();
                json.append("      \"successful_tasks\": ").append(successfulTasks).append(",\n");
                double successRate = completedTasks.isEmpty() ? 0 :
                    (double) successfulTasks / completedTasks.size();
                json.append("      \"success_rate\": ").append(String.format("%.3f", successRate)).append(",\n");

                double avgPlanningLatency = completedTasks.stream()
                    .mapToLong(t -> t.planningLatencyMs).average().orElse(0);
                json.append("      \"avg_planning_latency_ms\": ").append((long) avgPlanningLatency).append(",\n");

                double avgExecutionLatency = completedTasks.stream()
                    .mapToLong(t -> t.executionLatencyMs).average().orElse(0);
                json.append("      \"avg_execution_latency_ms\": ").append((long) avgExecutionLatency).append(",\n");

                double totalCostUsd = totalCostCents.get() / 100.0;
                json.append("      \"total_llm_cost_usd\": ").append(String.format("%.4f", totalCostUsd)).append(",\n");

                long totalTokens = completedTasks.stream()
                    .mapToLong(t -> t.inputTokens + t.outputTokens).sum();
                json.append("      \"total_tokens\": ").append(totalTokens).append(",\n");

                long totalCacheHits = completedTasks.stream().mapToLong(t -> t.cacheHits).sum();
                long totalLlmCalls = completedTasks.stream().mapToLong(t -> t.llmCalls).sum();
                double cacheHitRate = totalLlmCalls == 0 ? 0 : (double) totalCacheHits / totalLlmCalls;
                json.append("      \"cache_hit_rate\": ").append(String.format("%.3f", cacheHitRate)).append("\n");
                json.append("    },\n");

                // Individual task results
                json.append("    \"tasks\": [\n");
                for (int i = 0; i < completedTasks.size(); i++) {
                    CompletedTaskMetrics task = completedTasks.get(i);
                    json.append(task.toJson());
                    if (i < completedTasks.size() - 1) {
                        json.append(",");
                    }
                    json.append("\n");
                }
                json.append("    ]\n");
            }

            json.append("  }\n");
            json.append("}\n");

            writer.write(json.toString());
            LOGGER.info("Metrics exported to {}", filepath);
        } catch (IOException e) {
            LOGGER.error("Failed to export metrics to {}", filepath, e);
        }
    }

    /**
     * Get summary statistics as a formatted string.
     *
     * @return Summary string
     */
    public static String getSummary() {
        synchronized (completedTasks) {
            long totalTasks = completedTasks.size();
            long successfulTasks = completedTasks.stream().filter(t -> t.success).count();
            double successRate = totalTasks == 0 ? 0 : (double) successfulTasks / totalTasks;

            double avgPlanningLatency = completedTasks.stream()
                .mapToLong(t -> t.planningLatencyMs).average().orElse(0);

            double avgExecutionLatency = completedTasks.stream()
                .mapToLong(t -> t.executionLatencyMs).average().orElse(0);

            double totalCostUsd = totalCostCents.get() / 100.0;

            return String.format(
                "EvaluationMetrics{tasks=%d, success_rate=%.2f, avg_plan=%dms, avg_exec=%dms, cost=$%.2f}",
                totalTasks, successRate, (long) avgPlanningLatency,
                (long) avgExecutionLatency, totalCostUsd
            );
        }
    }

    /**
     * Reset all metrics for a new benchmark run.
     */
    public static void reset() {
        activeTasks.clear();
        synchronized (completedTasks) {
            completedTasks.clear();
        }
        totalCostCents.set(0);
        benchmarkRunId = UUID.randomUUID().toString();
        benchmarkStartTime = System.currentTimeMillis();
        PromptMetrics.reset();

        LOGGER.info("Metrics reset. New run ID: {}", benchmarkRunId);
    }

    /**
     * Get the current benchmark run ID.
     */
    public static String getBenchmarkRunId() {
        return benchmarkRunId;
    }

    /**
     * Get the total cost in USD for the current run.
     */
    public static double getTotalCostUsd() {
        return totalCostCents.get() / 100.0;
    }

    // ------------------------------------------------------------------------
    // Internal Helper Classes
    // ------------------------------------------------------------------------

    /**
     * Internal class for tracking active task metrics.
     */
    private static class TaskMetrics {
        final String agentName;
        final List<String> errors = new ArrayList<>();
        ExecutionPhase phase = ExecutionPhase.PLANNING;

        // Timing
        long planningStartTime;
        long planningLatencyMs;
        long executionStartTime;
        long executionLatencyMs;
        long totalLatencyMs;
        long completionTime;

        // Task generation
        int tasksGenerated;

        // Actions
        String currentAction;
        int actionsStarted;
        int actionsCompleted;
        int actionsSuccessful;
        int actionsFailed;

        // Results
        boolean success;
        double correctnessScore;
        Map<String, Object> results;

        // LLM metrics
        int llmCalls;
        int inputTokens;
        int outputTokens;
        double llmCostUsd;
        int cacheHits;
        int[] latencyBuckets = new int[4]; // <1s, 1-3s, 3-10s, >10s

        TaskMetrics(String agentName) {
            this.agentName = agentName;
        }
    }

    /**
     * Immutable snapshot of completed task metrics.
     */
    public static class CompletedTaskMetrics {
        public final String agentName;
        public final long planningLatencyMs;
        public final long executionLatencyMs;
        public final long totalLatencyMs;
        public final boolean success;
        public final double correctnessScore;
        public final int tasksGenerated;
        public final int llmCalls;
        public final int inputTokens;
        public final int outputTokens;
        public final double llmCostUsd;
        public final int cacheHits;
        public final int actionsStarted;
        public final int actionsCompleted;
        public final int actionsSuccessful;

        CompletedTaskMetrics(TaskMetrics metrics) {
            this.agentName = metrics.agentName;
            this.planningLatencyMs = metrics.planningLatencyMs;
            this.executionLatencyMs = metrics.executionLatencyMs;
            this.totalLatencyMs = metrics.totalLatencyMs;
            this.success = metrics.success;
            this.correctnessScore = metrics.correctnessScore;
            this.tasksGenerated = metrics.tasksGenerated;
            this.llmCalls = metrics.llmCalls;
            this.inputTokens = metrics.inputTokens;
            this.outputTokens = metrics.outputTokens;
            this.llmCostUsd = metrics.llmCostUsd;
            this.cacheHits = metrics.cacheHits;
            this.actionsStarted = metrics.actionsStarted;
            this.actionsCompleted = metrics.actionsCompleted;
            this.actionsSuccessful = metrics.actionsSuccessful;
        }

        public String toJson() {
            return String.format(
                "      {\n" +
                "        \"agent_name\": \"%s\",\n" +
                "        \"planning_latency_ms\": %d,\n" +
                "        \"execution_latency_ms\": %d,\n" +
                "        \"total_latency_ms\": %d,\n" +
                "        \"success\": %b,\n" +
                "        \"correctness_score\": %.2f,\n" +
                "        \"tasks_generated\": %d,\n" +
                "        \"llm_calls\": %d,\n" +
                "        \"input_tokens\": %d,\n" +
                "        \"output_tokens\": %d,\n" +
                "        \"llm_cost_usd\": %.6f,\n" +
                "        \"cache_hits\": %d,\n" +
                "        \"actions_started\": %d,\n" +
                "        \"actions_completed\": %d,\n" +
                "        \"actions_successful\": %d\n" +
                "      }",
                agentName, planningLatencyMs, executionLatencyMs, totalLatencyMs,
                success, correctnessScore, tasksGenerated, llmCalls,
                inputTokens, outputTokens, llmCostUsd, cacheHits,
                actionsStarted, actionsCompleted, actionsSuccessful
            );
        }
    }

    // ------------------------------------------------------------------------
    // Private Helper Methods
    // ------------------------------------------------------------------------

    private static TaskMetrics getOrCreateTaskMetrics(String agentName) {
        return activeTasks.computeIfAbsent(agentName, TaskMetrics::new);
    }

    private static TaskMetrics getTaskMetrics(String agentName) {
        return activeTasks.get(agentName);
    }

    private static String getSystemInfo() {
        return String.format("Java %s, OS %s, Processors %d",
            System.getProperty("java.version"),
            System.getProperty("os.name"),
            Runtime.getRuntime().availableProcessors()
        );
    }

    private static String escapeJson(String s) {
        return s.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}
