package com.minewright.client;

import com.mojang.blaze3d.systems.RenderSystem;
import com.minewright.MineWrightMod;
import com.minewright.entity.ForemanEntity;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.network.chat.Component;
import net.minecraftforge.client.event.RenderGuiOverlayEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;

import java.util.ArrayList;
import java.util.List;

/**
 * Side-mounted GUI panel for MineWright agent interaction.
 * Inspired by Cursor's composer - slides in/out from the right side.
 * Now with scrollable message history!
 */
public class ForemanOfficeGUI {
    private static final int PANEL_WIDTH = 200;
    private static final int PANEL_PADDING = 6;
    private static final int ANIMATION_SPEED = 20;
    private static final int MESSAGE_HEIGHT = 12;
    private static final int MAX_MESSAGES = 500;
    
    private static boolean isOpen = false;
    private static float slideOffset = PANEL_WIDTH; // Start fully hidden
    private static EditBox inputBox;
    private static List<String> commandHistory = new ArrayList<>();
    private static int historyIndex = -1;
    
    // Message history and scrolling
    private static List<ChatMessage> messages = new ArrayList<>();
    private static int scrollOffset = 0;
    private static int maxScroll = 0;
    private static final int BACKGROUND_COLOR = 0x15202020; // Ultra transparent (15 = ~8% opacity)
    private static final int BORDER_COLOR = 0x40404040; // More transparent border
    private static final int HEADER_COLOR = 0x25252525; // More transparent header (~15% opacity)
    private static final int TEXT_COLOR = 0xFFFFFFFF;
    
    // Message bubble colors
    private static final int USER_BUBBLE_COLOR = 0xC04CAF50; // Green bubble for user
    private static final int CREW_BUBBLE_COLOR = 0xC02196F3; // Blue bubble for Crew
    private static final int SYSTEM_BUBBLE_COLOR = 0xC0FF9800; // Orange bubble for system

    private static class ChatMessage {
        String sender; // "You", "Foreman", "Crew", "System", etc.
        String text;
        int bubbleColor;
        boolean isUser; // true if message from user

        ChatMessage(String sender, String text, int bubbleColor, boolean isUser) {
            this.sender = sender;
            this.text = text;
            this.bubbleColor = bubbleColor;
            this.isUser = isUser;
        }
    }

    // Crew status panel state
    private static boolean crewPanelExpanded = true;
    private static final int CREW_PANEL_HEIGHT = 140;
    private static final int CREW_PANEL_COLLAPSED_HEIGHT = 30;
    private static String targetedCrewMember = null; // Currently selected crew for commands

    // Status colors
    private static final int STATUS_IDLE_COLOR = 0xFF4CAF50;    // Green
    private static final int STATUS_WORKING_COLOR = 0xFF2196F3;  // Blue
    private static final int STATUS_PLANNING_COLOR = 0xFFFF9800; // Orange
    private static final int STATUS_COMBAT_COLOR = 0xFFF44336;   // Red

    public static void toggle() {
        isOpen = !isOpen;
        
        Minecraft mc = Minecraft.getInstance();
        
        if (isOpen) {
            initializeInputBox();
            mc.setScreen(new ForemanOverlayScreen());
            if (inputBox != null) {
                inputBox.setFocused(true);
            }
        } else {
            if (inputBox != null) {
                inputBox = null;
            }
            if (mc.screen instanceof ForemanOverlayScreen) {
                mc.setScreen(null);
            }
        }
    }

    public static boolean isOpen() {
        return isOpen;
    }

    private static void initializeInputBox() {
        Minecraft mc = Minecraft.getInstance();
        if (inputBox == null) {
            inputBox = new EditBox(mc.font, 0, 0, PANEL_WIDTH - 20, 20, 
                Component.literal("Command"));
            inputBox.setMaxLength(256);
            inputBox.setHint(Component.literal("Tell Foreman what to do..."));
            inputBox.setFocused(true);
        }
    }

    /**
     * Add a message to the chat history
     */
    public static void addMessage(String sender, String text, int bubbleColor, boolean isUser) {
        messages.add(new ChatMessage(sender, text, bubbleColor, isUser));
        if (messages.size() > MAX_MESSAGES) {
            messages.remove(0);
        }
        // Auto-scroll to bottom on new message
        scrollOffset = 0;
    }

    /**
     * Add a user command to the history
     */
    public static void addUserMessage(String text) {
        addMessage("You", text, USER_BUBBLE_COLOR, true);
    }

    /**
     * Add a Crew response to the history
     */
    public static void addCrewMessage(String crewName, String text) {
        addMessage(crewName, text, CREW_BUBBLE_COLOR, false);
    }

    /**
     * Add a system message to the history
     */
    public static void addSystemMessage(String text) {
        addMessage("System", text, SYSTEM_BUBBLE_COLOR, false);
    }

    @SubscribeEvent
    public static void onRenderOverlay(RenderGuiOverlayEvent.Post event) {
        if (event.getOverlay().id().toString().contains("hotbar")) {
            return; // Don't render over hotbar
        }

        Minecraft mc = Minecraft.getInstance();
        if (mc.player == null) return;

        if (isOpen && slideOffset > 0) {
            slideOffset = Math.max(0, slideOffset - ANIMATION_SPEED);
        } else if (!isOpen && slideOffset < PANEL_WIDTH) {
            slideOffset = Math.min(PANEL_WIDTH, slideOffset + ANIMATION_SPEED);
        }

        // Don't render if completely hidden
        if (slideOffset >= PANEL_WIDTH) return;

        GuiGraphics graphics = event.getGuiGraphics();
        int screenWidth = mc.getWindow().getGuiScaledWidth();
        int screenHeight = mc.getWindow().getGuiScaledHeight();
        
        int panelX = (int) (screenWidth - PANEL_WIDTH + slideOffset);
        int panelY = 0;
        int panelHeight = screenHeight;

        RenderSystem.enableBlend();
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
        RenderSystem.blendFuncSeparate(
            com.mojang.blaze3d.platform.GlStateManager.SourceFactor.SRC_ALPHA,
            com.mojang.blaze3d.platform.GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA,
            com.mojang.blaze3d.platform.GlStateManager.SourceFactor.ONE,
            com.mojang.blaze3d.platform.GlStateManager.DestFactor.ZERO
        );
        graphics.fillGradient(panelX, panelY, screenWidth, panelHeight, BACKGROUND_COLOR, BACKGROUND_COLOR);
        
        graphics.fillGradient(panelX - 2, panelY, panelX, panelHeight, BORDER_COLOR, BORDER_COLOR);

        int headerHeight = 35;
        graphics.fillGradient(panelX, panelY, screenWidth, headerHeight, HEADER_COLOR, HEADER_COLOR);
        graphics.drawString(mc.font, "§lMineWright", panelX + PANEL_PADDING, panelY + 8, TEXT_COLOR);
        graphics.drawString(mc.font, "§7Press K to close", panelX + PANEL_PADDING, panelY + 20, 0xFF888888);

        // Render crew status panel (collapsible)
        int crewPanelY = headerHeight;
        int crewPanelCurrentHeight = crewPanelExpanded ? CREW_PANEL_HEIGHT : CREW_PANEL_COLLAPSED_HEIGHT;
        renderCrewStatusPanel(graphics, mc, panelX, crewPanelY, screenWidth, crewPanelCurrentHeight);

        // Message history area
        int inputAreaY = screenHeight - 80;
        int messageAreaTop = crewPanelY + crewPanelCurrentHeight + 5;
        int messageAreaHeight = inputAreaY - messageAreaTop - 5;
        int messageAreaBottom = messageAreaTop + messageAreaHeight;

        int totalMessageHeight = 0;
        for (ChatMessage msg : messages) {
            int maxBubbleWidth = PANEL_WIDTH - (PANEL_PADDING * 3);
            int bubbleHeight = calculateBubbleHeight(mc.font, msg.text, maxBubbleWidth - 10);
            totalMessageHeight += bubbleHeight + 5 + 12; // message + spacing + name
        }
        maxScroll = Math.max(0, totalMessageHeight - messageAreaHeight);
        scrollOffset = Math.max(0, Math.min(scrollOffset, maxScroll));

        // Render messages (scrollable)
        int yPos = messageAreaTop + 5;
        
        // Clip rendering to message area
        graphics.enableScissor(panelX, messageAreaTop, screenWidth, messageAreaBottom);
        
        if (messages.isEmpty()) {
            graphics.drawString(mc.font, "§7No messages yet...", 
                panelX + PANEL_PADDING, yPos, 0xFF666666);
            graphics.drawString(mc.font, "§7Type a command below!", 
                panelX + PANEL_PADDING, yPos + 12, 0xFF555555);
        } else {
            int currentY = messageAreaBottom - 5; // Start from bottom
            
            for (int i = messages.size() - 1; i >= 0; i--) {
                ChatMessage msg = messages.get(i);

                int maxBubbleWidth = PANEL_WIDTH - (PANEL_PADDING * 3); // Leave space on sides
                List<String> wrappedLines = wrapText(mc.font, msg.text, maxBubbleWidth - 10);
                int bubbleWidth = calculateBubbleWidth(mc.font, msg.text, maxBubbleWidth - 10);
                int bubbleHeight = calculateBubbleHeight(mc.font, msg.text, maxBubbleWidth - 10);

                int msgY = currentY - bubbleHeight + scrollOffset;

                if (msgY + bubbleHeight < messageAreaTop - 20 || msgY > messageAreaBottom + 20) {
                    currentY -= bubbleHeight + 5;
                    continue;
                }

                // Render message bubble based on sender
                if (msg.isUser) {
                    int bubbleX = screenWidth - bubbleWidth - PANEL_PADDING - 5;

                    // Draw bubble background with gradient for alpha support
                    graphics.fillGradient(bubbleX - 3, msgY - 3, bubbleX + bubbleWidth + 3, msgY + bubbleHeight, msg.bubbleColor, msg.bubbleColor);

                    // Draw sender name (small, above bubble)
                    graphics.drawString(mc.font, "§7" + msg.sender, bubbleX, msgY - 12, 0xFFCCCCCC);

                    // Draw each line of the message
                    int lineY = msgY + 5;
                    for (String line : wrappedLines) {
                        graphics.drawString(mc.font, line, bubbleX + 5, lineY, 0xFFFFFFFF);
                        lineY += MESSAGE_HEIGHT;
                    }

                } else {
                    int bubbleX = panelX + PANEL_PADDING;

                    // Draw bubble background with gradient for alpha support
                    graphics.fillGradient(bubbleX - 3, msgY - 3, bubbleX + bubbleWidth + 3, msgY + bubbleHeight, msg.bubbleColor, msg.bubbleColor);

                    // Draw sender name (small, above bubble)
                    graphics.drawString(mc.font, "§l" + msg.sender, bubbleX, msgY - 12, TEXT_COLOR);

                    // Draw each line of the message
                    int lineY = msgY + 5;
                    for (String line : wrappedLines) {
                        graphics.drawString(mc.font, line, bubbleX + 5, lineY, 0xFFFFFFFF);
                        lineY += MESSAGE_HEIGHT;
                    }
                }

                currentY -= bubbleHeight + 5 + 12; // Extra space for sender name
            }
        }
        
        graphics.disableScissor();
        
        if (maxScroll > 0) {
            int scrollBarHeight = Math.max(20, (messageAreaHeight * messageAreaHeight) / (maxScroll + messageAreaHeight));
            int scrollBarY = messageAreaTop + (int)((messageAreaHeight - scrollBarHeight) * (1.0f - (float)scrollOffset / maxScroll));
            graphics.fill(screenWidth - 4, scrollBarY, screenWidth - 2, scrollBarY + scrollBarHeight, 0xFF888888);
        }

        // Command input area (bottom) with gradient for alpha support
        graphics.fillGradient(panelX, inputAreaY, screenWidth, screenHeight, HEADER_COLOR, HEADER_COLOR);
        graphics.drawString(mc.font, "§7Command:", panelX + PANEL_PADDING, inputAreaY + 10, 0xFF888888);

        if (inputBox != null && isOpen) {
            inputBox.setX(panelX + PANEL_PADDING);
            inputBox.setY(inputAreaY + 25);
            inputBox.setWidth(PANEL_WIDTH - (PANEL_PADDING * 2));
            inputBox.render(graphics, (int)mc.mouseHandler.xpos(), (int)mc.mouseHandler.ypos(), mc.getFrameTime());
        }

        graphics.drawString(mc.font, "§8Enter: Send | ↑↓: History | Scroll: Messages", 
            panelX + PANEL_PADDING, screenHeight - 15, 0xFF555555);
        
        RenderSystem.disableBlend();
    }

    /**
     * Proper word wrap for text that splits at word boundaries
     * @param font Minecraft font for width calculation
     * @param text Text to wrap
     * @param maxWidth Maximum width per line
     * @return List of wrapped lines
     */
    private static List<String> wrapText(net.minecraft.client.gui.Font font, String text, int maxWidth) {
        List<String> lines = new ArrayList<>();

        // Handle empty or null text
        if (text == null || text.isEmpty()) {
            lines.add("");
            return lines;
        }

        // If text fits in one line, return it
        if (font.width(text) <= maxWidth) {
            lines.add(text);
            return lines;
        }

        // Split into words, preserving spaces
        String[] words = text.split("(?<=\\s)");
        StringBuilder currentLine = new StringBuilder();

        for (String word : words) {
            // Try adding the word to the current line
            String testLine = currentLine + word;

            if (font.width(testLine) <= maxWidth) {
                // Word fits, add it
                currentLine.append(word);
            } else {
                // Word doesn't fit
                if (currentLine.length() == 0) {
                    // Single word is too long, break it up
                    String broken = breakLongWord(font, word, maxWidth);
                    String[] brokenLines = broken.split("\n");
                    for (int i = 0; i < brokenLines.length; i++) {
                        if (i > 0) {
                            lines.add(currentLine.toString().trim());
                            currentLine = new StringBuilder();
                        }
                        currentLine.append(brokenLines[i]);
                    }
                } else {
                    // Start a new line
                    lines.add(currentLine.toString().trim());
                    currentLine = new StringBuilder();

                    // Try fitting the word on the new line
                    testLine = currentLine + word;
                    if (font.width(testLine) <= maxWidth) {
                        currentLine.append(word);
                    } else {
                        // Word is still too long, break it
                        String broken = breakLongWord(font, word.trim(), maxWidth);
                        String[] brokenLines = broken.split("\n");
                        currentLine.append(brokenLines[0]);
                        for (int i = 1; i < brokenLines.length; i++) {
                            lines.add(currentLine.toString());
                            currentLine = new StringBuilder(brokenLines[i]);
                        }
                    }
                }
            }
        }

        // Add the last line if there's anything left
        if (currentLine.length() > 0) {
            lines.add(currentLine.toString().trim());
        }

        return lines;
    }

    /**
     * Break a long word that doesn't fit on one line
     * @param font Minecraft font for width calculation
     * @param word Word to break
     * @param maxWidth Maximum width per line
     * @return String with newlines inserted at break points
     */
    private static String breakLongWord(net.minecraft.client.gui.Font font, String word, int maxWidth) {
        StringBuilder result = new StringBuilder();
        StringBuilder currentLine = new StringBuilder();

        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            String testLine = currentLine.toString() + c;

            if (font.width(testLine) <= maxWidth) {
                currentLine.append(c);
            } else {
                if (currentLine.length() > 0) {
                    result.append(currentLine.toString());
                    result.append("\n");
                    currentLine = new StringBuilder();
                }
                currentLine.append(c);
            }
        }

        if (currentLine.length() > 0) {
            result.append(currentLine.toString());
        }

        return result.toString();
    }

    /**
     * Calculate the height needed for a message bubble based on wrapped text
     * @param font Minecraft font for width calculation
     * @param text Text to measure
     * @param maxWidth Maximum width per line
     * @return Total height for all lines
     */
    private static int calculateBubbleHeight(net.minecraft.client.gui.Font font, String text, int maxWidth) {
        List<String> lines = wrapText(font, text, maxWidth);
        int lineHeight = MESSAGE_HEIGHT;
        int padding = 10;
        return (lines.size() * lineHeight) + padding;
    }

    /**
     * Calculate the width needed for a message bubble based on wrapped text
     * @param font Minecraft font for width calculation
     * @param text Text to measure
     * @param maxWidth Maximum width per line
     * @return Actual width needed (width of widest line)
     */
    private static int calculateBubbleWidth(net.minecraft.client.gui.Font font, String text, int maxWidth) {
        List<String> lines = wrapText(font, text, maxWidth);
        int maxWidthNeeded = 0;

        for (String line : lines) {
            int lineWidth = font.width(line);
            if (lineWidth > maxWidthNeeded) {
                maxWidthNeeded = lineWidth;
            }
        }

        // Add padding
        return maxWidthNeeded + 10;
    }

    /**
     * Renders the crew status panel showing all active crew members
     * @param graphics GuiGraphics instance
     * @param mc Minecraft instance
     * @param x X position of panel
     * @param y Y position of panel
     * @param width Width of panel
     * @param height Current height (depends on expanded/collapsed state)
     */
    private static void renderCrewStatusPanel(GuiGraphics graphics, Minecraft mc, int x, int y, int width, int height) {
        // Panel background
        graphics.fillGradient(x, y, x + width, y + height, 0x20181818, 0x20181818);
        graphics.fillGradient(x, y, x + width, y + 1, 0x40404040, 0x40404040); // Top border
        graphics.fillGradient(x, y + height - 1, x + width, y + height, 0x40404040, 0x40404040); // Bottom border

        // Panel header (always visible)
        int headerY = y + 5;
        graphics.drawString(mc.font, "§lCrew Status", x + PANEL_PADDING, headerY, TEXT_COLOR);

        // Collapse/expand indicator
        String expandIndicator = crewPanelExpanded ? "▼" : "▶";
        graphics.drawString(mc.font, "§7" + expandIndicator, x + width - 20, headerY, 0xFF888888);

        // Crew count
        var crewMembers = MineWrightMod.getCrewManager().getAllCrewMembers();
        int crewCount = crewMembers.size();
        graphics.drawString(mc.font, "§7" + crewCount + " member" + (crewCount != 1 ? "s" : ""),
            x + PANEL_PADDING + 90, headerY, 0xFF888888);

        // Render crew member details if expanded
        if (crewPanelExpanded) {
            int crewY = y + 25;
            int crewIndex = 0;

            for (ForemanEntity crew : crewMembers) {
                if (crewY + 25 > y + height) break; // Don't render beyond panel

                renderCrewMember(graphics, mc, crew, x, crewY, width, crewIndex);
                crewY += 25;
                crewIndex++;
            }

            // Show message if no crew members
            if (crewCount == 0) {
                graphics.drawString(mc.font, "§7No crew members. Use 'spawn <name>' to create one!",
                    x + PANEL_PADDING, crewY, 0xFF666666);
            }
        }
    }

    /**
     * Renders a single crew member entry in the status panel
     * @param graphics GuiGraphics instance
     * @param mc Minecraft instance
     * @param crew The crew member entity
     * @param x X position
     * @param y Y position
     * @param width Panel width
     * @param index Index of this crew member (for background striping)
     */
    private static void renderCrewMember(GuiGraphics graphics, Minecraft mc, ForemanEntity crew, int x, int y, int width, int index) {
        // Alternating background for readability
        if (index % 2 == 0) {
            graphics.fillGradient(x + 2, y, x + width - 2, y + 24, 0x15151515, 0x15151515);
        }

        // Highlight if targeted
        if (crew.getSteveName().equals(targetedCrewMember)) {
            graphics.fillGradient(x + 2, y, x + width - 2, y + 24, 0x402196F3, 0x402196F3);
        }

        String crewName = crew.getSteveName();

        // Status indicator dot
        int statusColor = getStatusColor(crew);
        int dotX = x + PANEL_PADDING;
        int dotY = y + 8;
        graphics.fill(dotX, dotY, dotX + 6, dotY + 6, statusColor);
        graphics.fill(dotX + 1, dotY + 1, dotX + 5, dotY + 5, statusColor);

        // Crew name
        int nameX = dotX + 10;
        graphics.drawString(mc.font, "§l" + crewName, nameX, y + 3, TEXT_COLOR);

        // Health bar
        float healthPercent = crew.getHealth() / crew.getMaxHealth();
        int healthBarWidth = 50;
        int healthBarX = nameX + mc.font.width(crewName) + 10;
        int healthBarY = y + 6;

        // Health bar background
        graphics.fill(healthBarX, healthBarY, healthBarX + healthBarWidth, healthBarY + 6, 0xFF333333);

        // Health bar fill (green to red gradient based on health)
        int healthFillWidth = (int)(healthBarWidth * healthPercent);
        int healthColor = healthPercent > 0.5f ? 0xFF4CAF50 : (healthPercent > 0.25f ? 0xFFFFC107 : 0xFFF44336);
        graphics.fill(healthBarX, healthBarY, healthBarX + healthFillWidth, healthBarY + 6, healthColor);

        // Current action/status
        String statusText = getStatusText(crew);
        int statusX = x + PANEL_PADDING;
        graphics.drawString(mc.font, "§7" + statusText, statusX, y + 15, 0xFFCCCCCC);

        // Role badge
        String roleBadge = getRoleBadge(crew);
        int roleX = x + width - roleBadge.length() * 6 - PANEL_PADDING;
        graphics.drawString(mc.font, roleBadge, roleX, y + 3, getRoleColor(crew));
    }

    /**
     * Gets the status color for a crew member based on their current state
     */
    private static int getStatusColor(ForemanEntity crew) {
        if (crew.getActionExecutor().isPlanning()) {
            return STATUS_PLANNING_COLOR; // Orange - planning
        } else if (crew.getActionExecutor().isExecuting()) {
            String currentGoal = crew.getActionExecutor().getCurrentGoal();
            // Check if in combat (goal contains combat-related keywords)
            if (currentGoal != null && (currentGoal.toLowerCase().contains("attack") ||
                currentGoal.toLowerCase().contains("fight") || currentGoal.toLowerCase().contains("combat"))) {
                return STATUS_COMBAT_COLOR; // Red - combat
            }
            return STATUS_WORKING_COLOR; // Blue - working
        }
        return STATUS_IDLE_COLOR; // Green - idle
    }

    /**
     * Gets the status text for a crew member
     */
    private static String getStatusText(ForemanEntity crew) {
        if (crew.getActionExecutor().isPlanning()) {
            return "Planning...";
        }

        if (crew.getActionExecutor().isExecuting()) {
            String currentGoal = crew.getActionExecutor().getCurrentGoal();
            if (currentGoal != null && currentGoal.length() > 30) {
                return currentGoal.substring(0, 27) + "...";
            }
            return currentGoal != null ? currentGoal : "Working";
        }

        return "Idle";
    }

    /**
     * Gets the role badge text for a crew member
     */
    private static String getRoleBadge(ForemanEntity crew) {
        switch (crew.getRole()) {
            case FOREMAN:
                return "[F]";
            case WORKER:
                return "[W]";
            case SOLO:
            default:
                return "[S]";
        }
    }

    /**
     * Gets the color for a crew member's role badge
     */
    private static int getRoleColor(ForemanEntity crew) {
        switch (crew.getRole()) {
            case FOREMAN:
                return 0xFFFF9800; // Orange
            case WORKER:
                return 0xFF2196F3; // Blue
            case SOLO:
            default:
                return 0xFF888888; // Gray
        }
    }

    public static boolean handleKeyPress(int keyCode, int scanCode, int modifiers) {
        if (!isOpen || inputBox == null) return false;

        Minecraft mc = Minecraft.getInstance();
        
        // Escape key - close panel
        if (keyCode == 256) { // ESC
            toggle();
            return true;
        }
        
        // Enter key - send command
        if (keyCode == 257) {
            String command = inputBox.getValue().trim();
            if (!command.isEmpty()) {
                sendCommand(command);
                inputBox.setValue("");
                historyIndex = -1;
            }
            return true;
        }

        // Arrow up - previous command
        if (keyCode == 265 && !commandHistory.isEmpty()) { // UP
            if (historyIndex < commandHistory.size() - 1) {
                historyIndex++;
                inputBox.setValue(commandHistory.get(commandHistory.size() - 1 - historyIndex));
            }
            return true;
        }

        // Arrow down - next command
        if (keyCode == 264) { // DOWN
            if (historyIndex > 0) {
                historyIndex--;
                inputBox.setValue(commandHistory.get(commandHistory.size() - 1 - historyIndex));
            } else if (historyIndex == 0) {
                historyIndex = -1;
                inputBox.setValue("");
            }
            return true;
        }

        // Backspace, Delete, Home, End, Left, Right - pass to input box
        if (keyCode == 259 || keyCode == 261 || keyCode == 268 || keyCode == 269 || 
            keyCode == 263 || keyCode == 262) {
            inputBox.keyPressed(keyCode, scanCode, modifiers);
            return true;
        }

        return true; // Consume all keys to prevent game controls
    }

    public static boolean handleCharTyped(char codePoint, int modifiers) {
        if (isOpen && inputBox != null) {
            inputBox.charTyped(codePoint, modifiers);
            return true; // Consumed
        }
        return false;
    }

    public static void handleMouseClick(double mouseX, double mouseY, int button) {
        if (!isOpen) return;

        Minecraft mc = Minecraft.getInstance();
        int screenWidth = mc.getWindow().getGuiScaledWidth();
        int screenHeight = mc.getWindow().getGuiScaledHeight();
        int panelX = (int) (screenWidth - PANEL_WIDTH + slideOffset);

        // Check if clicking on crew status panel header (for toggle expand/collapse)
        int headerHeight = 35;
        int crewPanelY = headerHeight;
        int crewPanelCurrentHeight = crewPanelExpanded ? CREW_PANEL_HEIGHT : CREW_PANEL_COLLAPSED_HEIGHT;

        if (mouseX >= panelX && mouseX <= panelX + PANEL_WIDTH &&
            mouseY >= crewPanelY && mouseY <= crewPanelY + CREW_PANEL_COLLAPSED_HEIGHT) {
            crewPanelExpanded = !crewPanelExpanded;
            return;
        }

        // Check if clicking on a crew member to target them
        if (crewPanelExpanded && mouseY >= crewPanelY + 25 && mouseY <= crewPanelY + crewPanelCurrentHeight) {
            var crewMembers = MineWrightMod.getCrewManager().getAllCrewMembers();
            int crewY = crewPanelY + 25;
            int crewIndex = 0;

            for (ForemanEntity crew : crewMembers) {
                if (mouseY >= crewY && mouseY <= crewY + 24) {
                    // Toggle targeting
                    if (crew.getSteveName().equals(targetedCrewMember)) {
                        targetedCrewMember = null; // Untarget
                        addSystemMessage("Un-targeted " + crew.getSteveName());
                    } else {
                        targetedCrewMember = crew.getSteveName(); // Target
                        addSystemMessage("Targeted " + crew.getSteveName() + " for commands");
                    }
                    return;
                }
                crewY += 25;
                crewIndex++;
            }
        }

        if (inputBox != null) {
            int inputAreaY = screenHeight - 80;
            if (mouseY >= inputAreaY + 25 && mouseY <= inputAreaY + 45) {
                inputBox.setFocused(true);
            } else {
                inputBox.setFocused(false);
            }
        }
    }

    public static void handleMouseScroll(double scrollDelta) {
        if (!isOpen) return;
        
        int scrollAmount = (int)(scrollDelta * 3 * MESSAGE_HEIGHT);
        scrollOffset -= scrollAmount;
        scrollOffset = Math.max(0, Math.min(scrollOffset, maxScroll));
    }

    private static void sendCommand(String command) {
        Minecraft mc = Minecraft.getInstance();

        commandHistory.add(command);
        if (commandHistory.size() > 50) {
            commandHistory.remove(0);
        }

        addUserMessage(command);

        if (command.toLowerCase().startsWith("spawn ")) {
            String name = command.substring(6).trim();
            if (name.isEmpty()) name = "Foreman";
            if (mc.player != null) {
                mc.player.connection.sendCommand("steve spawn " + name);
                addSystemMessage("Spawning crew member: " + name);
            }
            return;
        }

        List<String> targetCrew = parseTargetCrew(command);

        // If no explicit targets and a crew member is targeted, use that
        if (targetCrew.isEmpty() && targetedCrewMember != null) {
            targetCrew.add(targetedCrewMember);
        }

        if (targetCrew.isEmpty()) {
            var crew = MineWrightMod.getCrewManager().getAllCrewMembers();
            if (!crew.isEmpty()) {
                targetCrew.add(crew.iterator().next().getSteveName());
            } else {
                // No crew members available
                addSystemMessage("No crew members found! Use 'spawn <name>' to create one.");
                return;
            }
        }

        // Send command to all targeted crew members
        if (mc.player != null) {
            for (String crewName : targetCrew) {
                mc.player.connection.sendCommand("minewright tell " + crewName + " " + command);
            }

            if (targetCrew.size() > 1) {
                addSystemMessage("→ " + String.join(", ", targetCrew) + ": " + command);
            } else {
                addSystemMessage("→ " + targetCrew.get(0) + ": " + command);
            }
        }
    }

    private static List<String> parseTargetCrew(String command) {
        List<String> targets = new ArrayList<>();
        String commandLower = command.toLowerCase();

        if (commandLower.startsWith("all crew ") || commandLower.startsWith("all ") ||
            commandLower.startsWith("everyone ") || commandLower.startsWith("everybody ")) {
            var allCrew = MineWrightMod.getCrewManager().getAllCrewMembers();
            for (ForemanEntity crew : allCrew) {
                targets.add(crew.getSteveName());
            }
            return targets;
        }

        var allCrew = MineWrightMod.getCrewManager().getAllCrewMembers();
        List<String> availableNames = new ArrayList<>();
        for (ForemanEntity crew : allCrew) {
            availableNames.add(crew.getSteveName().toLowerCase());
        }

        String[] parts = command.split(",");
        for (String part : parts) {
            String trimmed = part.trim();
            String firstWord = trimmed.split(" ")[0].toLowerCase();

            if (availableNames.contains(firstWord)) {
                for (ForemanEntity crew : allCrew) {
                    if (crew.getSteveName().equalsIgnoreCase(firstWord)) {
                        targets.add(crew.getSteveName());
                        break;
                    }
                }
            }
        }

        return targets;
    }

    public static void tick() {
        if (isOpen && inputBox != null) {
            inputBox.tick();
            // Auto-focus input box when panel is open
            if (!inputBox.isFocused()) {
                inputBox.setFocused(true);
            }
        }
    }
}
