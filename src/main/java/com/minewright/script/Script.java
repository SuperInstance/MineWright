package com.minewright.script;

import java.time.Instant;
import java.util.*;

/**
 * Represents an automation script that defines agent behaviors.
 *
 * <p>Scripts are reusable DSL programs that can be:</p>
 * <ul>
 *   <li>Generated by LLMs from natural language commands</li>
 *   <li>Loaded from template files</li>
 *   <li>Refined based on execution feedback</li>
 *   <li>Shared between agents</li>
 * </ul>
 *
 * <p><b>Script Structure:</b></p>
 * <pre>
 * Script {
 *   metadata: ScriptMetadata
 *   parameters: Map<String, Parameter>
 *   requirements: ScriptRequirements
 *   scriptNode: ScriptNode (root of behavior tree)
 *   errorHandlers: Map<FailureType, List<ScriptNode>>
 *   telemetry: ScriptTelemetry
 * }
 * </pre>
 *
 * @see ScriptNode
 * @see ScriptMetadata
 * @see ScriptParser
 * @since 1.3.0
 */
public class Script {

    private final ScriptMetadata metadata;
    private final Map<String, Parameter> parameters;
    private final ScriptRequirements requirements;
    private final ScriptNode scriptNode;
    private final Map<String, List<ScriptNode>> errorHandlers;
    private final ScriptTelemetry telemetry;
    private final Instant createdAt;
    private final String version;

    private Script(Builder builder) {
        this.metadata = builder.metadata;
        this.parameters = Collections.unmodifiableMap(new HashMap<>(builder.parameters));
        this.requirements = builder.requirements;
        this.scriptNode = builder.scriptNode;
        this.errorHandlers = Collections.unmodifiableMap(new HashMap<>(builder.errorHandlers));
        this.telemetry = builder.telemetry;
        this.createdAt = builder.createdAt != null ? builder.createdAt : Instant.now();
        this.version = builder.version;
    }

    /**
     * Creates a new builder for constructing scripts.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Creates a new builder initialized from this script.
     */
    public Builder toBuilder() {
        return new Builder(this);
    }

    // Getters
    public ScriptMetadata getMetadata() { return metadata; }
    public Map<String, Parameter> getParameters() { return parameters; }
    public ScriptRequirements getRequirements() { return requirements; }
    public ScriptNode getScriptNode() { return scriptNode; }
    public Map<String, List<ScriptNode>> getErrorHandlers() { return errorHandlers; }
    public ScriptTelemetry getTelemetry() { return telemetry; }
    public Instant getCreatedAt() { return createdAt; }
    public String getVersion() { return version; }

    /**
     * Gets the script ID.
     */
    public String getId() {
        return metadata != null ? metadata.getId() : null;
    }

    /**
     * Gets the script name.
     */
    public String getName() {
        return metadata != null ? metadata.getName() : null;
    }

    /**
     * Gets the script description.
     */
    public String getDescription() {
        return metadata != null ? metadata.getDescription() : null;
    }

    /**
     * Gets the script author.
     */
    public String getAuthor() {
        return metadata != null ? metadata.getAuthor() : null;
    }

    /**
     * Gets the script tags.
     */
    public List<String> getTags() {
        return metadata != null ? metadata.getTags() : Collections.emptyList();
    }

    /**
     * Creates a copy of this script.
     */
    public Script copy() {
        return this.toBuilder().build();
    }

    /**
     * Converts this script to DSL format.
     */
    public String toDSL() {
        StringBuilder sb = new StringBuilder();
        sb.append("# Script: ").append(getName()).append("\n");
        sb.append("# Version: ").append(version).append("\n\n");

        if (metadata != null) {
            sb.append("metadata:\n");
            sb.append("  id: \"").append(metadata.getId()).append("\"\n");
            sb.append("  name: \"").append(metadata.getName()).append("\"\n");
            sb.append("  description: \"").append(metadata.getDescription()).append("\"\n\n");
        }

        if (!parameters.isEmpty()) {
            sb.append("parameters:\n");
            for (Map.Entry<String, Parameter> entry : parameters.entrySet()) {
                Parameter param = entry.getValue();
                sb.append("  - name: \"").append(entry.getKey()).append("\"\n");
                sb.append("    type: \"").append(param.getType()).append("\"\n");
                if (param.getDefaultValue() != null) {
                    sb.append("    default: ").append(param.getDefaultValue()).append("\n");
                }
            }
            sb.append("\n");
        }

        sb.append("script:\n");
        appendNode(sb, scriptNode, 0);

        return sb.toString();
    }

    private void appendNode(StringBuilder sb, ScriptNode node, int indent) {
        String indentStr = "  ".repeat(indent);

        if (node == null) {
            sb.append(indentStr).append("# null node\n");
            return;
        }

        sb.append(indentStr).append("- type: \"").append(node.getType()).append("\"\n");

        if (node.getAction() != null) {
            sb.append(indentStr).append("  action: \"").append(node.getAction()).append("\"\n");
        }

        if (node.getCondition() != null) {
            sb.append(indentStr).append("  condition: \"").append(node.getCondition()).append("\"\n");
        }

        if (!node.getParameters().isEmpty()) {
            sb.append(indentStr).append("  params:\n");
            for (Map.Entry<String, Object> entry : node.getParameters().entrySet()) {
                sb.append(indentStr).append("    ").append(entry.getKey()).append(": ");
                sb.append(formatValue(entry.getValue())).append("\n");
            }
        }

        if (!node.getChildren().isEmpty()) {
            sb.append(indentStr).append("  children:\n");
            for (ScriptNode child : node.getChildren()) {
                appendNode(sb, child, indent + 2);
            }
        }
    }

    private String formatValue(Object value) {
        if (value instanceof String) {
            return "\"" + value + "\"";
        } else if (value instanceof Boolean) {
            return value.toString();
        } else {
            return String.valueOf(value);
        }
    }

    /**
     * Builder for constructing Script instances.
     */
    public static class Builder {
        private ScriptMetadata metadata;
        private Map<String, Parameter> parameters = new HashMap<>();
        private ScriptRequirements requirements;
        private ScriptNode scriptNode;
        private Map<String, List<ScriptNode>> errorHandlers = new HashMap<>();
        private ScriptTelemetry telemetry;
        private Instant createdAt;
        private String version = "1.0.0";

        private Builder() {}

        private Builder(Script existing) {
            this.metadata = existing.metadata;
            this.parameters = new HashMap<>(existing.parameters);
            this.requirements = existing.requirements;
            this.scriptNode = existing.scriptNode;
            this.errorHandlers = new HashMap<>(existing.errorHandlers);
            this.telemetry = existing.telemetry;
            this.createdAt = existing.createdAt;
            this.version = existing.version;
        }

        public Builder metadata(ScriptMetadata metadata) {
            this.metadata = metadata;
            return this;
        }

        public Builder addParameter(String name, Parameter parameter) {
            this.parameters.put(name, parameter);
            return this;
        }

        public Builder parameters(Map<String, Parameter> parameters) {
            this.parameters = new HashMap<>(parameters);
            return this;
        }

        public Builder requirements(ScriptRequirements requirements) {
            this.requirements = requirements;
            return this;
        }

        public Builder scriptNode(ScriptNode scriptNode) {
            this.scriptNode = scriptNode;
            return this;
        }

        public Builder addErrorHandler(String errorType, ScriptNode handler) {
            this.errorHandlers.computeIfAbsent(errorType, k -> new ArrayList<>()).add(handler);
            return this;
        }

        public Builder errorHandlers(Map<String, List<ScriptNode>> errorHandlers) {
            this.errorHandlers = new HashMap<>(errorHandlers);
            return this;
        }

        public Builder telemetry(ScriptTelemetry telemetry) {
            this.telemetry = telemetry;
            return this;
        }

        public Builder createdAt(Instant createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        public Builder version(String version) {
            this.version = version;
            return this;
        }

        public Script build() {
            return new Script(this);
        }
    }

    /**
     * Script metadata information.
     */
    public static class ScriptMetadata {
        private final String id;
        private final String name;
        private final String description;
        private final String author;
        private final List<String> tags;
        private final Instant createdAt;

        private ScriptMetadata(Builder builder) {
            this.id = builder.id;
            this.name = builder.name;
            this.description = builder.description;
            this.author = builder.author;
            this.tags = Collections.unmodifiableList(new ArrayList<>(builder.tags));
            this.createdAt = builder.createdAt != null ? builder.createdAt : Instant.now();
        }

        public static Builder builder() {
            return new Builder();
        }

        public String getId() { return id; }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public String getAuthor() { return author; }
        public List<String> getTags() { return tags; }
        public Instant getCreatedAt() { return createdAt; }

        public static class Builder {
            private String id;
            private String name;
            private String description;
            private String author;
            private List<String> tags = new ArrayList<>();
            private Instant createdAt;

            public Builder id(String id) { this.id = id; return this; }
            public Builder name(String name) { this.name = name; return this; }
            public Builder description(String description) { this.description = description; return this; }
            public Builder author(String author) { this.author = author; return this; }
            public Builder addTag(String tag) { this.tags.add(tag); return this; }
            public Builder tags(List<String> tags) { this.tags = new ArrayList<>(tags); return this; }
            public Builder createdAt(Instant createdAt) { this.createdAt = createdAt; return this; }

            public ScriptMetadata build() {
                if (id == null) {
                    id = UUID.randomUUID().toString().substring(0, 8);
                }
                return new ScriptMetadata(this);
            }
        }
    }

    /**
     * Script parameter definition.
     */
    public static class Parameter {
        private final String name;
        private final String type;
        private final Object defaultValue;
        private final boolean required;
        private final String description;

        public Parameter(String name, String type, Object defaultValue, boolean required, String description) {
            this.name = name;
            this.type = type;
            this.defaultValue = defaultValue;
            this.required = required;
            this.description = description;
        }

        public String getName() { return name; }
        public String getType() { return type; }
        public Object getDefaultValue() { return defaultValue; }
        public boolean isRequired() { return required; }
        public String getDescription() { return description; }
    }

    /**
     * Script execution requirements.
     */
    public static class ScriptRequirements {
        private final List<ItemRequirement> inventory;
        private final List<String> tools;
        private final int maxExecutionTime;
        private final int maxDistance;

        private ScriptRequirements(Builder builder) {
            this.inventory = Collections.unmodifiableList(new ArrayList<>(builder.inventory));
            this.tools = Collections.unmodifiableList(new ArrayList<>(builder.tools));
            this.maxExecutionTime = builder.maxExecutionTime;
            this.maxDistance = builder.maxDistance;
        }

        public static Builder builder() {
            return new Builder();
        }

        public List<ItemRequirement> getInventory() { return inventory; }
        public List<String> getTools() { return tools; }
        public int getMaxExecutionTime() { return maxExecutionTime; }
        public int getMaxDistance() { return maxDistance; }

        public static class Builder {
            private List<ItemRequirement> inventory = new ArrayList<>();
            private List<String> tools = new ArrayList<>();
            private int maxExecutionTime = 300; // 5 minutes
            private int maxDistance = 100;

            public Builder addInventoryItem(String item, int quantity) {
                this.inventory.add(new ItemRequirement(item, quantity));
                return this;
            }
            public Builder inventory(List<ItemRequirement> inventory) {
                this.inventory = new ArrayList<>(inventory);
                return this;
            }
            public Builder addTool(String tool) { this.tools.add(tool); return this; }
            public Builder tools(List<String> tools) { this.tools = new ArrayList<>(tools); return this; }
            public Builder maxExecutionTime(int seconds) {
                this.maxExecutionTime = seconds;
                return this;
            }
            public Builder maxDistance(int blocks) {
                this.maxDistance = blocks;
                return this;
            }

            public ScriptRequirements build() {
                return new ScriptRequirements(this);
            }
        }

        public record ItemRequirement(String item, int quantity) {}
    }

    /**
     * Script telemetry configuration.
     */
    public static class ScriptTelemetry {
        private final String logLevel;
        private final List<String> metrics;

        public ScriptTelemetry(String logLevel, List<String> metrics) {
            this.logLevel = logLevel;
            this.metrics = Collections.unmodifiableList(new ArrayList<>(metrics));
        }

        public String getLogLevel() { return logLevel; }
        public List<String> getMetrics() { return metrics; }
    }
}
